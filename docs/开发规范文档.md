# 河南麻将项目开发规范文档

## 1. 项目概述

本文档为河南麻将线上游戏项目的统一开发规范，涵盖前端、后端、数据库、测试等方面的开发标准，确保代码质量、可维护性和团队协作效率。

### 1.1 技术栈
- **前端**: Vue 3 + JavaScript + Element Plus + Vite + SCSS
- **后端**: Spring Boot 3.4.5 + JPA + MyBatis + MySQL + Redis
- **实时通信**: Socket.IO
- **构建工具**: Maven (后端) + Vite (前端)

## 2. 代码风格规范

### 2.1 通用规范
- 使用UTF-8编码
- 文件命名使用英文，避免中文和特殊字符
- 代码缩进使用2个空格（前端）或4个空格（后端）
- 行长度限制：120字符
- 禁止使用tab键，统一使用空格
- 前后端全文禁止禁止禁止is开头的实体属性！！！！！

### 2.2 命名规范

#### 2.2.1 文件命名
```
前端文件：
- 组件文件: PascalCase (GameTable.vue, PlayerHand.vue)
- 页面文件: PascalCase (GameRoom.vue, HomePage.vue)
- 工具文件: camelCase (gameUtils.ts, apiClient.ts)
- 样式文件: kebab-case (game-table.scss, player-hand.scss)

后端文件：
- Java类: PascalCase (GameService.java, RoomController.java)
- 配置文件: kebab-case (application.yml, mahjong-config.xml)
- Mapper文件: camelCase (gameMapper.xml, roomMapper.xml)
```

#### 2.2.2 变量和函数命名
```javascript
// 前端 - JavaScript
const currentPlayerId = 'player_001';
const gameRoomInfo = ref({});

// 函数命名 - 动词开头，驼峰命名
const joinGameRoom = async (roomId: string) => {};
const handlePlayerAction = (action: Object) => {};
const isGameReady = computed(() => {});

// 组件Props - 使用JSDoc注释
/**
 * @typedef {Object} Props
 * @property {Object} roomData - 房间数据
 * @property {number} playerPosition - 玩家位置
 * @property {boolean} [isSpectator] - 是否观战
 */
```

```java
// 后端 - Java
public class GameService {
    private String currentRoomId;
    private List<PlayerInfo> playerList;

    // 方法命名 - 动词开头，驼峰命名
    public GameResult startGame(String roomId) {}
    public void handlePlayerAction(String playerId, PlayerAction action) {}
    public boolean isRoomReady(String roomId) {}
}
```

### 2.3 注释规范

#### 2.3.1 文件头注释
```javascript
/**
 * @fileoverview 游戏房间管理组件
 * @author 开发者姓名
 * @created 2024-01-01
 * @updated 2024-01-01
 */
```

```java
/**
 * 游戏服务类 - 处理游戏核心逻辑
 * @author 开发者姓名
 * @since 1.0.0
 */
@Service
public class GameService {
}
```

#### 2.3.2 函数/方法注释
```javascript
/**
 * 加入游戏房间
 * @param {string} roomId 房间ID
 * @param {Object} playerInfo 玩家信息
 * @returns {Promise<Object>} 房间信息
 * @throws {Error} 加入房间失败时抛出异常
 */
const joinGameRoom = async (roomId, playerInfo) => {};
```

```java
/**
 * 开始游戏
 * @param roomId 房间ID
 * @return 游戏结果
 * @throws RoomNotFoundException 房间不存在
 * @throws NotEnoughPlayersException 玩家数量不足
 */
public GameResult startGame(String roomId) throws RoomNotFoundException {
}
```

## 3. 前端开发规范

### 3.1 组件设计原则

#### 3.1.1 单一职责原则
```typescript
// ❌ 错误示例 - 一个组件处理多个职责
<template>
  <div>
    <!-- 房间管理 + 游戏逻辑 + UI渲染 -->
  </div>
</template>

// ✅ 正确示例 - 职责分离
<template>
  <GameRoom>
    <RoomHeader />
    <GameTable />
    <PlayerControls />
    <ChatPanel />
  </GameRoom>
</template>
```

#### 3.1.2 组件复用性
```typescript
// 通用组件设计
// components/common/BaseModal.vue
<template>
  <el-dialog
    v-model="visible"
    :title="title"
    :width="width"
    :before-close="handleClose"
  >
    <slot />
    <template #footer>
      <slot name="footer">
        <el-button @click="handleClose">取消</el-button>
        <el-button type="primary" @click="handleConfirm">确定</el-button>
      </slot>
    </template>
  </el-dialog>
</template>

// 使用示例
<BaseModal v-model="showCreateRoom" title="创建房间">
  <CreateRoomForm @submit="handleCreateRoom" />
</BaseModal>
```

### 3.2 状态管理规范

#### 3.2.1 Pinia Store设计
```javascript
// stores/game.js
export const useGameStore = defineStore('game', {
  state: () => ({
    currentGame: null,
    playerHand: [],
    gameState: GameState.WAITING,
    currentPlayer: 0,
  }),

  getters: {
    isMyTurn: (state) => (playerId) =>
      state.currentGame?.currentPlayer === playerId,

    canPlayTile: (state) => state.gameState === GameState.PLAYING,

    handTileCount: (state) => state.playerHand.length,
  },

  actions: {
    async startGame(roomId) {
      try {
        const response = await gameApi.startGame(roomId);
        this.currentGame = response.data;
        this.gameState = GameState.PLAYING;
      } catch (error) {
        throw new Error('开始游戏失败');
      }
    },

    async playTile(tileId) {
      if (!this.canPlayTile) {
        throw new Error('当前不能出牌');
      }

      await gameApi.playTile(this.currentGame.id, tileId);
    },
  },
});
```

### 3.3 API封装规范

#### 3.3.1 统一API客户端
```javascript
// utils/api.js
class ApiClient {
  constructor() {
    this.baseURL = import.meta.env.VITE_API_BASE_URL;
    this.socket = io(this.baseURL);
    this.setupInterceptors();
  }

  // REST API封装
  async post(url, data) {
    try {
      const response = await axios.post(`${this.baseURL}${url}`, data);
      return response.data;
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  // WebSocket事件监听
  on(event, callback) {
    this.socket.on(event, callback);
  }

  // 发送WebSocket事件
  emit(event, data) {
    this.socket.emit(event, data);
  }
}

export const apiClient = new ApiClient();
```

#### 3.3.2 API模块化
```javascript
// api/game.js
export const gameApi = {
  // 获取房间信息
  getRoomInfo: (roomId) =>
    apiClient.get(`/rooms/${roomId}`),

  // 创建房间
  createRoom: (roomData) =>
    apiClient.post('/rooms', roomData),

  // 开始游戏
  startGame: (roomId) =>
    apiClient.post(`/rooms/${roomId}/start`),

  // 玩家操作
  playerAction: (gameId, action) =>
    apiClient.post(`/games/${gameId}/action`, action),
};

// WebSocket事件
export const gameEvents = {
  onGameStart: (callback) =>
    apiClient.on('game-started', callback),

  onPlayerAction: (callback) =>
    apiClient.on('player-action', callback),

  onGameEnd: (callback) =>
    apiClient.on('game-ended', callback),
};
```

### 3.4 样式开发规范

#### 3.4.1 SCSS变量管理
```scss
// styles/variables.scss
// 颜色系统
$primary-color: #409eff;
$success-color: #67c23a;
$warning-color: #e6a23c;
$danger-color: #f56c6c;
$info-color: #909399;

// 游戏主题色
$game-bg-color: #2c3e50;
$table-bg-color: #27ae60;
$tile-bg-color: #ecf0f1;
$tile-border-color: #34495e;

// 间距系统
$spacing-xs: 4px;
$spacing-sm: 8px;
$spacing-md: 16px;
$spacing-lg: 24px;
$spacing-xl: 32px;

// 字体大小
$font-size-xs: 12px;
$font-size-sm: 14px;
$font-size-md: 16px;
$font-size-lg: 18px;
$font-size-xl: 20px;

// 断点
$mobile-breakpoint: 768px;
$tablet-breakpoint: 1024px;
$desktop-breakpoint: 1200px;
```

#### 3.4.2 组件样式规范
```scss
// GameTable.vue
<style lang="scss" scoped>
@import '@/styles/variables.scss';
@import '@/styles/mixins.scss';

.game-table {
  width: 100%;
  background: $game-bg-color;
  border-radius: $spacing-md;
  padding: $spacing-lg;

  // 响应式设计
  @include respond-to('mobile') {
    padding: $spacing-sm;
    border-radius: $spacing-sm;
  }

  // 子元素样式
  &__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: $spacing-md;
  }

  &__content {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: $spacing-md;

    @include respond-to('mobile') {
      grid-template-columns: 1fr;
      gap: $spacing-sm;
    }
  }

  // 状态样式
  &--waiting {
    opacity: 0.6;
  }

  &--playing {
    opacity: 1;
  }
}

// 麻将牌样式
.mahjong-tile {
  width: 60px;
  height: 80px;
  background: $tile-bg-color;
  border: 2px solid $tile-border-color;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: $font-size-lg;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  }

  &--selected {
    background: $primary-color;
    color: white;
    transform: translateY(-10px);
  }

  &--disabled {
    opacity: 0.5;
    cursor: not-allowed;

    &:hover {
      transform: none;
    }
  }
}
</style>
```

#### 3.4.3 响应式设计规范
```scss
// styles/mixins.scss
@mixin respond-to($breakpoint) {
  @if $breakpoint == 'mobile' {
    @media (max-width: $mobile-breakpoint) {
      @content;
    }
  }
  @if $breakpoint == 'tablet' {
    @media (min-width: $mobile-breakpoint + 1) and (max-width: $tablet-breakpoint) {
      @content;
    }
  }
  @if $breakpoint == 'desktop' {
    @media (min-width: $tablet-breakpoint + 1) {
      @content;
    }
  }
}

// Flex布局工具类
@mixin flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

@mixin flex-between {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

@mixin flex-column {
  display: flex;
  flex-direction: column;
}

// 游戏专用样式
@mixin game-card {
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  padding: $spacing-lg;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  }
}
```

## 4. 后端开发规范

### 4.1 项目结构规范

```
src/main/java/com/mahjong/
├── MahjongApplication.java          # 启动类
├── config/                          # 配置类
│   ├── DatabaseConfig.java
│   ├── WebSocketConfig.java
│   └── RedisConfig.java
├── controller/                      # 控制器层
│   ├── GameController.java
│   ├── RoomController.java
│   └── PlayerController.java
├── service/                        # 业务逻辑层
│   ├── impl/                        # 实现类
│   ├── GameService.java
│   ├── RoomService.java
│   └── PlayerService.java
├── repository/                      # 数据访问层(JPA)
│   ├── GameRepository.java
│   └── RoomRepository.java
├── mapper/                          # MyBatis映射器
│   ├── GameMapper.java
│   └── RoomMapper.java
├── entity/                          # 实体类
│   ├── Game.java
│   ├── Room.java
│   └── Player.java
├── dto/                            # 数据传输对象
│   ├── request/                    # 请求DTO
│   └── response/                   # 响应DTO
├── enums/                          # 枚举类
├── utils/                          # 工具类
├── exception/                      # 异常处理
├── websocket/                      # WebSocket处理
└── constants/                      # 常量定义
```

### 4.2 代码分层规范

#### 4.2.1 Controller层规范
```java
@RestController
@RequestMapping("/api/v1/rooms")
@Validated
@Slf4j
public class RoomController {

    private final RoomService roomService;

    public RoomController(RoomService roomService) {
        this.roomService = roomService;
    }

    /**
     * 创建房间
     */
    @PostMapping
    public ResponseEntity<ApiResponse<RoomResponse>> createRoom(
            @Valid @RequestBody CreateRoomRequest request) {
        try {
            RoomResponse room = roomService.createRoom(request);
            return ResponseEntity.ok(ApiResponse.success(room));
        } catch (BusinessException e) {
            log.warn("创建房间失败: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(e.getMessage()));
        }
    }

    /**
     * 获取房间信息
     */
    @GetMapping("/{roomId}")
    public ResponseEntity<ApiResponse<RoomResponse>> getRoom(
            @PathVariable String roomId) {
        RoomResponse room = roomService.getRoom(roomId);
        return ResponseEntity.ok(ApiResponse.success(room));
    }
}
```

#### 4.2.2 Service层规范
```java
@Service
@Transactional
@Slf4j
public class RoomServiceImpl implements RoomService {

    private final RoomRepository roomRepository;
    private final GameService gameService;
    private final WebSocketService webSocketService;

    public RoomServiceImpl(RoomRepository roomRepository,
                          GameService gameService,
                          WebSocketService webSocketService) {
        this.roomRepository = roomRepository;
        this.gameService = gameService;
        this.webSocketService = webSocketService;
    }

    @Override
    public RoomResponse createRoom(CreateRoomRequest request) {
        // 参数验证
        validateCreateRoomRequest(request);

        // 创建房间实体
        Room room = buildRoomFromRequest(request);

        // 保存到数据库
        room = roomRepository.save(room);

        // 发送WebSocket事件
        webSocketService.sendToRoom(room.getId(), "room-created", room);

        // 记录日志
        log.info("房间创建成功: roomId={}, creator={}",
                room.getId(), request.getCreatorId());

        return RoomResponse.fromEntity(room);
    }

    private void validateCreateRoomRequest(CreateRoomRequest request) {
        if (StringUtils.isBlank(request.getCreatorId())) {
            throw new BusinessException("创建者ID不能为空");
        }
        // 更多验证逻辑...
    }
}
```

#### 4.2.3 Repository层规范
```java
@Repository
public interface RoomRepository extends JpaRepository<Room, Long> {

    // 根据房间号查找
    Optional<Room> findByRoomNumber(String roomNumber);

    // 查找创建者的房间
    List<Room> findByCreatorId(String creatorId);

    // 查找活跃房间
    @Query("SELECT r FROM Room r WHERE r.status = :status AND r.expiresAt > :now")
    List<Room> findActiveRooms(@Param("status") RoomStatus status,
                               @Param("now") LocalDateTime now);

    // 自定义更新操作
    @Modifying
    @Query("UPDATE Room r SET r.playerCount = r.playerCount + 1 WHERE r.id = :roomId")
    void incrementPlayerCount(@Param("roomId") Long roomId);
}
```

### 4.3 异常处理规范

#### 4.3.1 自定义异常类
```java
// 业务异常基类
public class BusinessException extends RuntimeException {
    private final String errorCode;

    public BusinessException(String message) {
        super(message);
        this.errorCode = "BUSINESS_ERROR";
    }

    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}

// 具体业务异常
public class RoomNotFoundException extends BusinessException {
    public RoomNotFoundException(String roomId) {
        super("ROOM_NOT_FOUND", String.format("房间不存在: %s", roomId));
    }
}

public class NotEnoughPlayersException extends BusinessException {
    public NotEnoughPlayersException(int current, int required) {
        super("NOT_ENOUGH_PLAYERS",
              String.format("玩家数量不足，当前: %d，需要: %d", current, required));
    }
}
```

#### 4.3.2 全局异常处理
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(
            BusinessException e) {
        log.warn("业务异常: {}", e.getMessage());
        return ResponseEntity.badRequest()
                .body(ApiResponse.error(e.getErrorCode(), e.getMessage()));
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            ValidationException e) {
        log.warn("参数验证异常: {}", e.getMessage());
        return ResponseEntity.badRequest()
                .body(ApiResponse.error("VALIDATION_ERROR", e.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGenericException(
            Exception e) {
        log.error("系统异常", e);
        return ResponseEntity.internalServerError()
                .body(ApiResponse.error("SYSTEM_ERROR", "系统内部错误"));
    }
}
```

### 4.4 数据传输对象规范

#### 4.4.1 Request DTO
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateRoomRequest {

    @NotBlank(message = "房间名称不能为空")
    @Size(max = 50, message = "房间名称长度不能超过50个字符")
    private String roomName;

    @NotBlank(message = "创建者ID不能为空")
    private String creatorId;

    @Min(value = 2, message = "最小玩家数量为2")
    @Max(value = 4, message = "最大玩家数量为4")
    private Integer maxPlayers = 4;

    private Boolean allowSpectate = true;

    private GameConfigRequest gameConfig;

    @Data
    public static class GameConfigRequest {
        private Integer baseScore = 1;
        private Integer maxRounds = 8;
        private Boolean allowPeng = true;
        private Boolean allowGang = true;
        private Boolean mixedTileEnabled = true;
        private Integer thinkTime = 30;
    }
}
```

#### 4.4.2 Response DTO
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RoomResponse {

    private Long id;
    private String roomNumber;
    private String roomName;
    private String creatorId;
    private Integer maxPlayers;
    private Integer currentPlayers;
    private Integer spectatorCount;
    private RoomStatus status;
    private Boolean allowSpectate;
    private List<PlayerResponse> players;
    private GameConfigResponse gameConfig;
    private LocalDateTime createdAt;

    public static RoomResponse fromEntity(Room room) {
        return RoomResponse.builder()
                .id(room.getId())
                .roomNumber(room.getRoomNumber())
                .roomName(room.getRoomName())
                .creatorId(room.getCreatorId())
                .maxPlayers(room.getMaxPlayers())
                .currentPlayers(room.getCurrentPlayers())
                .spectatorCount(room.getSpectatorCount())
                .status(room.getStatus())
                .allowSpectate(room.getAllowSpectate())
                .players(room.getPlayers().stream()
                        .map(PlayerResponse::fromEntity)
                        .collect(Collectors.toList()))
                .gameConfig(GameConfigResponse.fromJson(room.getGameConfig()))
                .createdAt(room.getCreatedAt())
                .build();
    }
}
```

### 4.5 WebSocket处理规范

#### 4.5.1 WebSocket配置
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws/mahjong")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic/", "/queue/");
        registry.setApplicationDestinationPrefixes("/app");
    }
}
```

#### 4.5.2 WebSocket事件处理
```java
@Component
@Slf4j
public class GameWebSocketHandler {

    private final SimpMessagingTemplate messagingTemplate;
    private final GameService gameService;

    public GameWebSocketHandler(SimpMessagingTemplate messagingTemplate,
                               GameService gameService) {
        this.messagingTemplate = messagingTemplate;
        this.gameService = gameService;
    }

    @EventListener
    @Async
    public void handleGameEvent(GameEvent event) {
        try {
            String destination = String.format("/topic/room/%s", event.getRoomId());
            messagingTemplate.convertAndSend(destination, event);

            log.debug("游戏事件推送成功: roomId={}, eventType={}",
                     event.getRoomId(), event.getEventType());
        } catch (Exception e) {
            log.error("游戏事件推送失败: roomId={}, eventType={}",
                     event.getRoomId(), event.getEventType(), e);
        }
    }

    public void sendToPlayer(String playerId, String event, Object data) {
        String destination = String.format("/queue/player/%s", playerId);
        messagingTemplate.convertAndSend(destination, Map.of(
                "event", event,
                "data", data,
                "timestamp", Instant.now()
        ));
    }
}
```

## 5. 数据库开发规范

### 5.1 表设计规范

#### 5.1.1 表命名和字段命名
```sql
-- 表命名：使用复数形式，小写加下划线
CREATE TABLE rooms (
    -- 主键：统一使用id，自增
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',

    -- 业务字段：使用小写加下划线
    room_number VARCHAR(8) NOT NULL COMMENT '房间号',
    room_name VARCHAR(50) DEFAULT '' COMMENT '房间名称',
    creator_id VARCHAR(36) NOT NULL COMMENT '创建者ID',

    -- 状态字段：使用枚举类型
    room_status ENUM('WAITING', 'PLAYING', 'FINISHED') DEFAULT 'WAITING' COMMENT '房间状态',

    -- 计数字段：使用明确的名称
    max_players TINYINT DEFAULT 4 COMMENT '最大玩家数',
    current_players TINYINT DEFAULT 0 COMMENT '当前玩家数',
    spectator_count TINYINT DEFAULT 0 COMMENT '观战人数',

    -- 标记字段：使用is_前缀
    allow_spectate BOOLEAN DEFAULT TRUE COMMENT '是否允许观战',
    is_deleted BOOLEAN DEFAULT FALSE COMMENT '是否已删除',

    -- 时间字段：统一命名
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    expires_at TIMESTAMP NULL COMMENT '过期时间',

    -- 索引
    UNIQUE KEY uk_room_number (room_number),
    INDEX idx_creator_id (creator_id),
    INDEX idx_room_status (room_status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='房间信息表';
```

#### 5.1.2 字段类型选择规范
```sql
-- 主键：根据数据量选择
id BIGINT PRIMARY KEY AUTO_INCREMENT  -- 大数据量
id INT PRIMARY KEY AUTO_INCREMENT     -- 中小数据量

-- 字符串类型：根据长度选择
player_name VARCHAR(20)               -- 固定长度
description TEXT                     -- 长文本
config_json JSON                     -- JSON数据

-- 数值类型：根据范围选择
score INT DEFAULT 0                  -- 整数
price DECIMAL(10,2)                 -- 小数
is_active BOOLEAN DEFAULT FALSE      -- 布尔值

-- 时间类型：根据需求选择
created_at TIMESTAMP                  -- 时间戳
birth_date DATE                     -- 日期
expire_time TIME                    -- 时间
```

### 5.2 索引使用规范

#### 5.2.1 索引设计原则
```sql
-- 1. 主键自动创建聚簇索引
PRIMARY KEY (id)

-- 2. 唯一索引：确保数据唯一性
UNIQUE KEY uk_room_number (room_number)

-- 3. 普通索引：提高查询性能
INDEX idx_creator_id (creator_id)

-- 4. 复合索引：优化多条件查询
INDEX idx_status_created (room_status, created_at)
INDEX idx_room_player (room_id, player_id)

-- 5. 前缀索引：减少索引大小
INDEX idx_player_name_prefix (player_name(10))
```

#### 5.2.2 避免索引误用
```sql
-- ❌ 错误：在大文本字段上创建索引
INDEX idx_description (description)

-- ❌ 错误：频繁更新的字段不适合建索引
INDEX idx_last_active (last_active_at)

-- ❌ 错误：重复的索引
INDEX idx_player_id (player_id)
INDEX idx_user_id (player_id)  -- 重复
```

### 5.3 SQL编写规范

#### 5.3.1 查询语句规范
```sql
-- ✅ 正确：使用明确的字段列表
SELECT id, room_number, room_name, creator_id
FROM rooms
WHERE room_status = 'WAITING'
ORDER BY created_at DESC
LIMIT 10;

-- ❌ 错误：使用SELECT *
SELECT * FROM rooms WHERE room_status = 'WAITING';

-- ✅ 正确：使用参数化查询
SELECT id, player_name
FROM players
WHERE room_id = ? AND player_status = ?;

-- ✅ 正确：使用JOIN而不是子查询
SELECT r.id, r.room_number, p.player_name
FROM rooms r
INNER JOIN players p ON r.id = p.room_id
WHERE r.room_status = 'PLAYING';

-- ❌ 错误：在WHERE子句中使用函数
SELECT * FROM rooms WHERE YEAR(created_at) = 2024;
-- ✅ 正确：使用范围查询
SELECT * FROM rooms WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
```

#### 5.3.2 分页查询优化
```sql
-- ✅ 推荐：使用基于ID的分页（游标分页）
SELECT id, room_number, room_name
FROM rooms
WHERE id > ? AND room_status = 'WAITING'
ORDER BY id ASC
LIMIT 20;

-- ✅ 可用：传统的LIMIT分页（适合数据量不大）
SELECT id, room_number, room_name
FROM rooms
WHERE room_status = 'WAITING'
ORDER BY created_at DESC
LIMIT 20 OFFSET 100;

-- ❌ 避免：大偏移量的分页查询
SELECT * FROM rooms ORDER BY created_at DESC LIMIT 20 OFFSET 100000;
```

### 5.4 事务使用规范

#### 5.4.1 事务边界控制
```java
@Service
@Transactional
public class GameServiceImpl implements GameService {

    // ✅ 正确：在Service层管理事务
    public GameResult startGame(String roomId) {
        Room room = roomRepository.findById(roomId)
                .orElseThrow(() -> new RoomNotFoundException(roomId));

        // 业务逻辑处理
        Game game = createGame(room);

        // 保存游戏记录
        game = gameRepository.save(game);

        // 发送WebSocket事件
        webSocketService.sendGameStart(roomId, game);

        return GameResult.fromEntity(game);
    }

    // ✅ 正确：只读操作使用只读事务
    @Transactional(readOnly = true)
    public List<RoomInfo> getAvailableRooms() {
        return roomRepository.findAvailableRooms()
                .stream()
                .map(RoomInfo::fromEntity)
                .collect(Collectors.toList());
    }
}
```

#### 5.4.2 事务传播行为
```java
@Service
public class PlayerServiceImpl implements PlayerService {

    // ✅ 正确：需要新事务的操作
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updatePlayerStatistics(String playerId, GameResult result) {
        // 独立事务更新统计数据
        PlayerStatistics stats = getOrCreateStatistics(playerId);
        stats.updateGameResult(result);
        statisticsRepository.save(stats);
    }

    // ✅ 正确：支持当前事务
    @Transactional(propagation = Propagation.SUPPORTS)
    public PlayerInfo getPlayerInfo(String playerId) {
        return playerRepository.findById(playerId)
                .map(PlayerInfo::fromEntity)
                .orElse(null);
    }
}
```

## 6. 测试开发规范

### 6.1 前端测试规范

#### 6.1.1 单元测试
```javascript
// tests/unit/components/GameTable.spec.js
import { mount } from '@vue/test-utils';
import { describe, it, expect, vi } from 'vitest';
import GameTable from '@/components/game/GameTable.vue';

describe('GameTable', () => {
  it('应该正确渲染游戏桌面', () => {
    const wrapper = mount(GameTable, {
      props: {
        roomData: {
          id: '1',
          players: [],
          gameState: 'WAITING'
        }
      }
    });

    expect(wrapper.find('.game-table').exists()).toBe(true);
    expect(wrapper.text()).toContain('游戏桌面');
  });

  it('应该在玩家准备后触发开始游戏事件', async () => {
    const wrapper = mount(GameTable, {
      props: {
        roomData: {
          id: '1',
          players: [
            { id: '1', name: 'Player1', isReady: true },
            { id: '2', name: 'Player2', isReady: true },
            { id: '3', name: 'Player3', isReady: true },
            { id: '4', name: 'Player4', isReady: true }
          ],
          gameState: 'WAITING'
        }
      }
    });

    await wrapper.vm.$nextTick();

    expect(wrapper.emitted('game-start')).toBeTruthy();
  });
});
```

#### 6.1.2 组件测试
```javascript
// tests/unit/components/PlayerHand.spec.js
import { mount } from '@vue/test-utils';
import { describe, it, expect, beforeEach } from 'vitest';
import PlayerHand from '@/components/game/PlayerHand.vue';

describe('PlayerHand', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(PlayerHand, {
      props: {
        tiles: [
          { id: '1', type: 'bamboo', value: '1' },
          { id: '2', type: 'bamboo', value: '2' },
          { id: '3', type: 'bamboo', value: '3' }
        ],
        isMyTurn: true,
        disabled: false
      }
    });
  });

  it('应该正确渲染手牌', () => {
    const tiles = wrapper.findAll('.mahjong-tile');
    expect(tiles.length).toBe(3);
  });

  it('应该允许在我的回合点击牌', async () => {
    const firstTile = wrapper.find('.mahjong-tile');
    await firstTile.trigger('click');

    expect(wrapper.emitted('tile-click')).toBeTruthy();
    expect(wrapper.emitted('tile-click')[0]).toEqual(['1']);
  });

  it('应该在非我的回合禁用牌点击', async () => {
    await wrapper.setProps({ isMyTurn: false });

    const firstTile = wrapper.find('.mahjong-tile');
    await firstTile.trigger('click');

    expect(wrapper.emitted('tile-click')).toBeFalsy();
  });
});
```

#### 6.1.3 集成测试
```javascript
// tests/integration/game-flow.spec.js
import { mount } from '@vue/test-utils';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import GameRoom from '@/pages/GameRoom.vue';
import { useGameStore } from '@/stores/game';

// Mock API
vi.mock('@/api/game', () => ({
  gameApi: {
    getRoomInfo: vi.fn(),
    startGame: vi.fn(),
    playerAction: vi.fn()
  }
}));

describe('Game Room Flow', () => {
  let wrapper;
  let gameStore;

  beforeEach(() => {
    // 创建Pinia store
    const pinia = createPinia();
    setActivePinia(pinia);
    gameStore = useGameStore();

    wrapper = mount(GameRoom, {
      global: {
        plugins: [pinia]
      },
      props: {
        roomId: 'test-room-123'
      }
    });
  });

  it('应该完整执行游戏开始流程', async () => {
    // 1. 进入房间
    expect(wrapper.find('.room-loading').exists()).toBe(true);

    // 2. 模拟房间加载完成
    await wrapper.vm.loadRoomData();
    expect(wrapper.find('.game-room').exists()).toBe(true);

    // 3. 玩家准备
    await wrapper.vm.handlePlayerReady();
    expect(gameStore.playerStates['player1'].isReady).toBe(true);

    // 4. 所有人准备后自动开始游戏
    await wrapper.vm.checkGameStart();
    expect(wrapper.emitted('game-started')).toBeTruthy();
  });
});
```

### 6.2 后端测试规范

#### 6.2.1 单元测试
```java
@ExtendWith(MockitoExtension.class)
class GameServiceTest {

    @Mock
    private GameRepository gameRepository;

    @Mock
    private RoomService roomService;

    @Mock
    private WebSocketService webSocketService;

    @InjectMocks
    private GameServiceImpl gameService;

    @Test
    void shouldStartGameSuccessfully() {
        // Given
        String roomId = "test-room-123";
        Room room = createTestRoom(roomId);
        when(roomService.getRoom(roomId)).thenReturn(room);
        when(gameRepository.save(any(Game.class))).thenAnswer(i -> i.getArgument(0));

        // When
        GameResult result = gameService.startGame(roomId);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getGameId()).isNotNull();
        assertThat(result.getStatus()).isEqualTo(GameStatus.PLAYING);

        verify(gameRepository).save(any(Game.class));
        verify(webSocketService).sendGameStart(roomId, any(Game.class));
    }

    @Test
    void shouldThrowExceptionWhenRoomNotFound() {
        // Given
        String roomId = "non-existent-room";
        when(roomService.getRoom(roomId))
                .thenThrow(new RoomNotFoundException(roomId));

        // When & Then
        assertThatThrownBy(() -> gameService.startGame(roomId))
                .isInstanceOf(RoomNotFoundException.class)
                .hasMessageContaining("房间不存在");

        verify(gameRepository, never()).save(any(Game.class));
        verify(webSocketService, never()).sendGameStart(any(), any());
    }

    private Room createTestRoom(String roomId) {
        return Room.builder()
                .id(1L)
                .roomNumber(roomId)
                .status(RoomStatus.WAITING)
                .currentPlayers(4)
                .maxPlayers(4)
                .build();
    }
}
```

#### 6.2.2 集成测试
```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
@Transactional
class GameIntegrationTest {

    @Autowired
    private GameService gameService;

    @Autowired
    private RoomService roomService;

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void shouldCompleteFullGameFlow() {
        // 1. 创建房间
        CreateRoomRequest request = CreateRoomRequest.builder()
                .roomName("Test Room")
                .creatorId("player1")
                .maxPlayers(4)
                .build();

        ResponseEntity<ApiResponse<RoomResponse>> createResponse = restTemplate.postForEntity(
                "/api/v1/rooms", request, new ParameterizedTypeReference<ApiResponse<RoomResponse>>() {});

        assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(createResponse.getBody().isSuccess()).isTrue();

        RoomResponse room = createResponse.getBody().getData();
        String roomId = room.getRoomNumber();

        // 2. 加入房间
        for (int i = 2; i <= 4; i++) {
            JoinRoomRequest joinRequest = JoinRoomRequest.builder()
                    .playerId("player" + i)
                    .playerName("Player " + i)
                    .build();

            ResponseEntity<ApiResponse<Void>> joinResponse = restTemplate.postForEntity(
                    "/api/v1/rooms/" + roomId + "/join", joinRequest,
                    new ParameterizedTypeReference<ApiResponse<Void>>() {});

            assertThat(joinResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        }

        // 3. 开始游戏
        ResponseEntity<ApiResponse<GameResponse>> startResponse = restTemplate.postForEntity(
                "/api/v1/rooms/" + roomId + "/start", null,
                new ParameterizedTypeReference<ApiResponse<GameResponse>>() {});

        assertThat(startResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(startResponse.getBody().getData().getStatus()).isEqualTo(GameStatus.PLAYING);
    }
}
```

#### 6.2.3 控制器测试
```java
@WebMvcTest(RoomController.class)
class RoomControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private RoomService roomService;

    @Test
    void shouldCreateRoomSuccessfully() throws Exception {
        // Given
        CreateRoomRequest request = CreateRoomRequest.builder()
                .roomName("Test Room")
                .creatorId("player1")
                .maxPlayers(4)
                .build();

        RoomResponse expectedResponse = RoomResponse.builder()
                .id(1L)
                .roomNumber("1234567")
                .roomName("Test Room")
                .creatorId("player1")
                .currentPlayers(1)
                .maxPlayers(4)
                .status(RoomStatus.WAITING)
                .build();

        when(roomService.createRoom(any(CreateRoomRequest.class)))
                .thenReturn(expectedResponse);

        // When & Then
        mockMvc.perform(post("/api/v1/rooms")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.success").value(true))
                .andExpect(jsonPath("$.data.roomNumber").value("1234567"))
                .andExpect(jsonPath("$.data.roomName").value("Test Room"));

        verify(roomService).createRoom(any(CreateRoomRequest.class));
    }
}
```

## 7. 性能优化规范

### 7.1 前端性能优化

#### 7.1.1 组件懒加载
```javascript
// router/index.js
const routes = [
  {
    path: '/game-room/:roomId',
    name: 'GameRoom',
    component: () => import('@/pages/GameRoom.vue'),
    meta: {
      requiresAuth: false,
      keepAlive: true
    }
  }
];

// 组件异步加载
import { defineAsyncComponent } from 'vue';

const GameTable = defineAsyncComponent(() =>
  import('@/components/game/GameTable.vue')
);

// 带加载状态的异步组件
const AsyncGameTable = defineAsyncComponent({
  loader: () => import('@/components/game/GameTable.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorMessage,
  delay: 200,
  timeout: 3000
});
```

#### 7.1.2 状态管理优化
```javascript
// stores/game.js
export const useGameStore = defineStore('game', {
  state: () => ({
    // 使用浅层响应式数据
    currentGame: shallowRef(null),
    playerHand: shallowRef([]),
    // 大数据使用普通ref
    gameHistory: ref([]),
  }),

  getters: {
    // 使用缓存getter
    playableTiles: (state) => {
      return computed(() =>
        state.playerHand.value.filter(tile => tile.canPlay)
      ).value;
    },

    // 分页计算
    paginatedHistory: (state) => {
      return (page, pageSize) => {
        const start = (page - 1) * pageSize;
        return state.gameHistory.value.slice(start, start + pageSize);
      };
    }
  },

  actions: {
    // 批量更新减少响应式开销
    updateGameState(updates) {
      Object.assign(this.$state, updates);
    },

    // 使用防抖处理频繁操作
    debouncedSaveGame: debounce(function() {
      this.saveGameToStorage();
    }, 1000)
  }
});
```

#### 7.1.3 虚拟滚动
```vue
<!-- components/game/GameHistory.vue -->
<template>
  <div class="game-history">
    <VirtualList
      :items="gameHistory"
      :item-size="60"
      :container-height="400"
      v-slot="{ item, index }"
    >
      <div class="history-item" :key="item.id">
        <span class="history-index">#{{ index + 1 }}</span>
        <span class="history-content">{{ item.description }}</span>
        <span class="history-time">{{ formatTime(item.timestamp) }}</span>
      </div>
    </VirtualList>
  </div>
</template>

<script setup>
import { VirtualList } from '@tanstack/vue-virtual';

// 使用JSDoc定义props类型
/**
 * @typedef {Object} HistoryItem
 * @property {string} id - 历史记录ID
 * @property {string} description - 描述
 * @property {Date} timestamp - 时间戳
 */

/** @type {{ gameHistory: HistoryItem[] }} */
const props = defineProps({
  gameHistory: Array
});

const formatTime = (timestamp) => {
  return new Intl.DateTimeFormat('zh-CN', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  }).format(timestamp);
};
</script>
```

### 7.2 后端性能优化

#### 7.2.1 数据库查询优化
```java
@Repository
public interface GameRepository extends JpaRepository<Game, Long> {

    // ✅ 使用投影减少数据传输
    @Query("SELECT new com.mahjong.dto.response.GameSummaryDTO(g.id, g.status, g.createdAt) " +
           "FROM Game g WHERE g.room.id = :roomId ORDER BY g.createdAt DESC")
    List<GameSummaryDTO> findGameSummariesByRoomId(@Param("roomId") Long roomId);

    // ✅ 使用分页查询
    @Query("SELECT g FROM Game g WHERE g.status = :status")
    Page<Game> findGamesByStatus(@Param("status") GameStatus status, Pageable pageable);

    // ✅ 使用批量查询避免N+1问题
    @Query("SELECT g FROM Game g JOIN FETCH g.players WHERE g.room.id = :roomId")
    List<Game> findGamesWithPlayersByRoomId(@Param("roomId") Long roomId);
}

@Service
public class GameServiceImpl implements GameService {

    // ✅ 使用缓存减少数据库查询
    @Cacheable(value = "games", key = "#roomId")
    public Game getCurrentGame(Long roomId) {
        return gameRepository.findCurrentGameByRoomId(roomId)
                .orElse(null);
    }

    // ✅ 使用批量操作
    @Transactional
    public void batchUpdatePlayerScores(List<PlayerScoreUpdate> updates) {
        List<Player> players = updates.stream()
                .map(update -> playerRepository.findById(update.getPlayerId())
                        .orElseThrow(() -> new PlayerNotFoundException(update.getPlayerId())))
                .collect(Collectors.toList());

        // 批量更新
        players.forEach(player -> {
            PlayerScoreUpdate update = updates.stream()
                    .filter(u -> u.getPlayerId().equals(player.getId()))
                    .findFirst()
                    .orElse(null);
            if (update != null) {
                player.setTotalScore(player.getTotalScore() + update.getScoreChange());
            }
        });

        playerRepository.saveAll(players);
    }
}
```

#### 7.2.2 缓存使用规范
```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))  // 默认30分钟过期
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .transactionAware()
                .build();
    }
}

@Service
public class RoomServiceImpl implements RoomService {

    // 缓存房间信息
    @Cacheable(value = "rooms", key = "#roomId", unless = "#result == null")
    public RoomResponse getRoom(String roomId) {
        Room room = roomRepository.findByRoomNumber(roomId)
                .orElseThrow(() -> new RoomNotFoundException(roomId));
        return RoomResponse.fromEntity(room);
    }

    // 更新时清除缓存
    @CacheEvict(value = "rooms", key = "#roomId")
    public void updateRoom(String roomId, UpdateRoomRequest request) {
        Room room = roomRepository.findByRoomNumber(roomId)
                .orElseThrow(() -> new RoomNotFoundException(roomId));

        // 更新逻辑
        room.setRoomName(request.getRoomName());
        room.setGameConfig(request.getGameConfig());

        roomRepository.save(room);
    }

    // 定时刷新缓存
    @Cacheable(value = "active-rooms", key = "'all'")
    public List<RoomResponse> getActiveRooms() {
        return roomRepository.findActiveRooms()
                .stream()
                .map(RoomResponse::fromEntity)
                .collect(Collectors.toList());
    }
}
```

#### 7.2.3 异步处理
```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "gameTaskExecutor")
    public ThreadPoolTaskExecutor gameTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("Game-Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

@Service
public class GameWebSocketHandler {

    // 异步发送WebSocket消息
    @Async("gameTaskExecutor")
    public void broadcastGameEvent(String roomId, GameEvent event) {
        try {
            messagingTemplate.convertAndSend("/topic/room/" + roomId, event);
        } catch (Exception e) {
            log.error("发送游戏事件失败: roomId={}, eventType={}",
                     roomId, event.getEventType(), e);
        }
    }

    // 异步处理游戏结束逻辑
    @Async("gameTaskExecutor")
    @EventListener
    public void handleGameEnd(GameEndEvent event) {
        // 更新统计数据
        playerStatisticsService.updateStatistics(event.getResult());

        // 清理临时数据
        gameDataService.cleanupGameData(event.getGameId());

        // 发送通知
        notificationService.sendGameEndNotification(event);
    }
}
```

## 8. 安全开发规范

### 8.1 前端安全规范

#### 8.1.1 XSS防护
```javascript
// utils/security.js
/**
 * HTML转义函数
 * @param {string} text - 要转义的文本
 * @returns {string} 转义后的HTML
 */
export const escapeHtml = (text) => {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
};

/**
 * 安全渲染HTML内容
 * @param {string} html - HTML字符串
 * @returns {string} 安全的HTML
 */
export const safeHtml = (html) => {
  // 移除危险的标签和属性
  return html
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
    .replace(/on\w+="[^"]*"/gi, '')
    .replace(/javascript:/gi, '');
};

/**
 * 安全的URL处理
 * @param {string} url - URL字符串
 * @returns {string} 安全的URL
 */
export const safeUrl = (url) => {
  try {
    const parsed = new URL(url, window.location.origin);
    // 只允许http和https协议
    if (['http:', 'https:'].includes(parsed.protocol)) {
      return parsed.toString();
    }
  } catch (e) {
    // URL解析失败，返回安全值
  }
  return '#';
};

// 在Vue组件中使用
<template>
  <div v-html="safeHtml(userMessage)"></div>
  <a :href="safeUrl(externalLink)">安全链接</a>
</template>
```

#### 8.1.2 输入验证
```javascript
// utils/validation.js

/**
 * 验证输入
 * @param {string} value - 要验证的值
 * @param {Object} rules - 验证规则
 * @returns {string|null} 错误信息或null
 */
export const validateInput = (value, rules) => {
  // 必填验证
  if (rules.required && (!value || value.trim().length === 0)) {
    return '此字段为必填项';
  }

  // 长度验证
  if (rules.maxLength && value.length > rules.maxLength) {
    return `长度不能超过${rules.maxLength}个字符`;
  }

  if (rules.minLength && value.length < rules.minLength) {
    return `长度不能少于${rules.minLength}个字符`;
  }

  // 格式验证
  if (rules.pattern && !rules.pattern.test(value)) {
    return '格式不正确';
  }

  // 自定义验证
  if (rules.custom) {
    const result = rules.custom(value);
    if (typeof result === 'string') {
      return result;
    }
    if (!result) {
      return '验证失败';
    }
  }

  return null;
};

// 常用验证规则
export const playerValidationRules = {
  playerName: {
    required: true,
    maxLength: 20,
    minLength: 2,
    pattern: /^[\u4e00-\u9fa5a-zA-Z0-9_]+$/,
    custom: (value) => {
      // 禁止敏感词
      const forbiddenWords = ['admin', 'root', '系统', '管理员'];
      return !forbiddenWords.some(word => value.toLowerCase().includes(word));
    }
  },
  roomName: {
    required: true,
    maxLength: 50,
    minLength: 1
  }
};
```

#### 8.1.3 Content Security Policy
```typescript
// main.ts - 设置CSP
const setSecurityHeaders = () => {
  const meta = document.createElement('meta');
  meta.httpEquiv = 'Content-Security-Policy';
  meta.content = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'", // 开发环境需要unsafe-inline和unsafe-eval
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "connect-src 'self' ws: wss:",
    "font-src 'self' data:",
    "object-src 'none'",
    "media-src 'self'",
    "frame-src 'none'"
  ].join('; ');
  document.head.appendChild(meta);
};

setSecurityHeaders();

// 生产环境的严格CSP
if (import.meta.env.PROD) {
  const meta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
  if (meta) {
    meta.content = [
      "default-src 'self'",
      "script-src 'self'",
      "style-src 'self'",
      "img-src 'self' data:",
      "connect-src 'self' wss:",
      "font-src 'self'",
      "object-src 'none'",
      "media-src 'self'",
      "frame-src 'none'"
    ].join('; ');
  }
}
```

### 8.2 后端安全规范

#### 8.2.1 SQL注入防护
```java
// ✅ 正确：使用参数化查询
@Repository
public interface PlayerRepository extends JpaRepository<Player, String> {

    @Query("SELECT p FROM Player p WHERE p.roomId = :roomId AND p.playerName = :playerName")
    List<Player> findByRoomIdAndPlayerName(@Param("roomId") Long roomId,
                                          @Param("playerName") String playerName);

    // ✅ 正确：使用原生SQL参数化查询
    @Query(value = "SELECT * FROM players WHERE room_id = ?1 AND player_status = ?2",
           nativeQuery = true)
    List<Player> findByRoomIdAndStatus(Long roomId, String status);
}

// ❌ 错误：拼接SQL字符串（存在SQL注入风险）
public List<Player> searchPlayers(String roomId, String keyword) {
    String sql = "SELECT * FROM players WHERE room_id = " + roomId +
                 " AND player_name LIKE '%" + keyword + "%'";
    return entityManager.createNativeQuery(sql, Player.class).getResultList();
}
```

#### 8.2.2 输入验证和过滤
```java
// DTO验证
@Data
public class CreateRoomRequest {

    @NotBlank(message = "房间名称不能为空")
    @Size(min = 1, max = 50, message = "房间名称长度必须在1-50个字符之间")
    @Pattern(regexp = "^[\\u4e00-\\u9fa5a-zA-Z0-9_\\s]+$",
             message = "房间名称只能包含中文、英文、数字、下划线和空格")
    private String roomName;

    @NotBlank(message = "创建者ID不能为空")
    @Size(min = 1, max = 36, message = "创建者ID长度不能超过36个字符")
    private String creatorId;

    @Min(value = 2, message = "最小玩家数量为2")
    @Max(value = 4, message = "最大玩家数量为4")
    private Integer maxPlayers = 4;
}

// 服务层验证
@Service
public class RoomServiceImpl implements RoomService {

    public RoomResponse createRoom(CreateRoomRequest request) {
        // 1. 基础验证
        validateCreateRoomRequest(request);

        // 2. 业务逻辑验证
        validateBusinessRules(request);

        // 3. 安全检查
        validateSecurityConstraints(request);

        // 创建房间逻辑
        Room room = buildRoomFromRequest(request);
        room = roomRepository.save(room);

        return RoomResponse.fromEntity(room);
    }

    private void validateSecurityConstraints(CreateRoomRequest request) {
        // 检查敏感词
        if (containsSensitiveWords(request.getRoomName())) {
            throw new BusinessException("房间名称包含敏感词汇");
        }

        // 检查频率限制
        if (isCreateRoomRateLimited(request.getCreatorId())) {
            throw new BusinessException("创建房间频率过快，请稍后再试");
        }
    }

    private boolean containsSensitiveWords(String text) {
        String[] sensitiveWords = {"admin", "root", "系统", "管理员", "官方"};
        String lowerText = text.toLowerCase();
        return Arrays.stream(sensitiveWords)
                .anyMatch(lowerText::contains);
    }
}
```

#### 8.2.3 接口安全控制
```java
@RestController
@RequestMapping("/api/v1/rooms")
@Validated
public class RoomController {

    private final RoomService roomService;
    private final RateLimiter rateLimiter;

    // 接口频率限制
    @PostMapping
    public ResponseEntity<ApiResponse<RoomResponse>> createRoom(
            @Valid @RequestBody CreateRoomRequest request,
            HttpServletRequest httpRequest) {

        // IP频率检查
        String clientIp = getClientIp(httpRequest);
        if (!rateLimiter.tryAcquire(clientIp, 10, TimeUnit.MINUTES)) {
            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                    .body(ApiResponse.error("RATE_LIMIT", "请求过于频繁"));
        }

        try {
            RoomResponse room = roomService.createRoom(request);
            return ResponseEntity.ok(ApiResponse.success(room));
        } catch (BusinessException e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(e.getMessage()));
        }
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xForwardedFor)) {
            return xForwardedFor.split(",")[0].trim();
        }

        String xRealIp = request.getHeader("X-Real-IP");
        if (StringUtils.hasText(xRealIp)) {
            return xRealIp;
        }

        return request.getRemoteAddr();
    }
}

// 安全配置
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // 暂时禁用CSRF（根据实际需求调整）
            .sessionManagement(session -> session
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/api/v1/rooms/**").permitAll() // 根据实际需求调整
                    .requestMatchers("/ws/**").permitAll()
                    .anyRequest().permitAll())
            .headers(headers -> headers
                    .frameOptions().deny()
                    .contentTypeOptions().and()
                    .httpStrictTransportSecurity(hstsConfig -> hstsConfig
                            .maxAgeInSeconds(31536000)
                            .includeSubdomains(true)));

        return http.build();
    }
}
```

## 9. Git工作流规范

### 9.1 分支管理规范

#### 9.1.1 分支策略
```
main                 # 主分支，生产环境代码
├── develop         # 开发分支，集成最新功能
├── feature/xxx     # 功能分支，开发新功能
├── hotfix/xxx      # 热修复分支，修复生产环境bug
├── release/xxx     # 发布分支，准备发布版本
└── bugfix/xxx      # bug修复分支，修复开发环境bug
```

#### 9.1.2 分支命名规范
```
功能分支：feature/room-management
功能分支：feature/game-logic
功能分支：feature/user-interface

热修复分支：hotfix/memory-leak
热修复分支：hotfix/security-patch

发布分支：release/v1.0.0
发布分支：release/v1.1.0

Bug修复分支：bugfix/player-score-calculation
Bug修复分支：bugfix/websocket-disconnect
```

### 9.2 提交信息规范

#### 9.2.1 提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 9.2.2 提交类型
```
feat:     新功能
fix:      bug修复
docs:     文档更新
style:    代码格式调整（不影响功能）
refactor: 代码重构
test:     测试相关
chore:    构建过程或辅助工具的变动
perf:     性能优化
revert:   回滚之前的提交
```

#### 9.2.3 提交信息示例
```
feat(game): 添加河南麻将游戏核心逻辑

- 实现牌的创建和分发逻辑
- 添加吃、碰、杠、胡操作支持
- 实现游戏状态管理和规则验证
- 添加混牌（赖子）功能

Closes #123

fix(websocket): 修复断线重连问题

- 添加心跳机制保持连接
- 实现断线后的自动重连
- 优化重连时的状态同步

Fixes #145

docs(api): 更新API文档

- 添加房间管理API说明
- 更新游戏操作接口文档
- 添加WebSocket事件说明
```

### 9.3 代码审查规范

#### 9.3.1 Pull Request模板
```markdown
## 变更描述
简要描述本次变更的内容和目的

## 变更类型
- [ ] 新功能
- [ ] Bug修复
- [ ] 代码重构
- [ ] 文档更新
- [ ] 性能优化
- [ ] 其他

## 测试情况
- [ ] 单元测试已通过
- [ ] 集成测试已通过
- [ ] 手动测试已完成
- [ ] 代码覆盖率检查通过

## 检查清单
- [ ] 代码符合项目编码规范
- [ ] 已添加必要的注释
- [ ] 已更新相关文档
- [ ] 无明显的性能问题
- [ ] 无安全漏洞

## 相关Issue
Closes #(issue number)

## 截图（如适用）
如果是UI相关变更，请提供截图

## 其他说明
其他需要审查者注意的信息
```

#### 9.3.2 代码审查要点
```
1. 代码质量
   - 是否符合编码规范
   - 是否有明显的代码异味
   - 是否有合理的错误处理

2. 功能完整性
   - 是否实现了所有需求功能
   - 是否有遗漏的边界情况
   - 是否有必要的输入验证

3. 性能和安全
   - 是否有性能隐患
   - 是否有安全漏洞
   - 是否遵循最佳实践

4. 测试覆盖
   - 是否有足够的测试用例
   - 测试用例是否覆盖边界情况
   - 测试是否易于维护

5. 文档和注释
   - 代码注释是否充分
   - 是否更新了相关文档
   - API文档是否准确
```

## 10. 部署和运维规范

### 10.1 环境配置规范

#### 10.1.1 环境分类
```
dev     # 开发环境，用于日常开发调试
test    # 测试环境，用于功能测试
staging # 预发布环境，用于发布前验证
prod    # 生产环境，正式对外提供服务
```

#### 10.1.2 配置管理
```yaml
# application.yml
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}

  # 数据库配置
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/mahjong_dev}
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    driver-class-name: com.mysql.cj.jdbc.Driver

  # Redis配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms

# 开发环境配置
---
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:mysql://localhost:3306/mahjong_dev
    username: root
    password: dev_password

  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

  devtools:
    restart:
      enabled: true

# 测试环境配置
---
spring:
  config:
    activate:
      on-profile: test

  datasource:
    url: jdbc:mysql://test-db:3306/mahjong_test
    username: test_user
    password: test_password

  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate

# 生产环境配置
---
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate

logging:
  level:
    com.mahjong: INFO
    org.springframework.web: WARN
  file:
    name: /var/log/mahjong/application.log
    max-size: 100MB
    max-history: 30
```

### 10.2 Docker容器化规范

#### 10.2.1 后端Dockerfile
```dockerfile
# 多阶段构建
FROM maven:3.9-openjdk-21 AS builder

WORKDIR /app
COPY pom.xml .
COPY src ./src

# 构建应用
RUN mvn clean package -DskipTests

# 运行镜像
FROM openjdk:21-jre-slim

# 创建应用用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 安装必要工具
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# 复制jar包
COPY --from=builder /app/target/mahjong-*.jar app.jar

# 设置权限
RUN chown -R appuser:appuser /app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", "-XX:+UseContainerSupport", "-XX:MaxRAMPercentage=75.0", "-jar", "app.jar"]
```

#### 10.2.2 前端Dockerfile

```dockerfile
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源码
COPY .. .

# 构建应用
RUN npm run build

# 运行阶段
FROM nginx:alpine

# 复制nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 创建非root用户
RUN addgroup -g 1001 -S nginx && \
    adduser -S nginx -u 1001 -G nginx

# 设置权限
RUN chown -R nginx:nginx /usr/share/nginx/html && \
    chown -R nginx:nginx /var/cache/nginx && \
    chown -R nginx:nginx /var/log/nginx && \
    chown -R nginx:nginx /etc/nginx/conf.d

USER nginx

# 暴露端口
EXPOSE 80

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

CMD ["nginx", "-g", "daemon off;"]
```

#### 10.2.3 Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: mahjong-backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_URL=jdbc:mysql://mysql:3306/mahjong_prod
      - DB_USERNAME=mahjong_user
      - DB_PASSWORD=mahjong_password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - mysql
      - redis
    volumes:
      - ./logs:/var/log/mahjong
    networks:
      - mahjong-network
    restart: unless-stopped

  # 前端服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: mahjong-frontend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
    networks:
      - mahjong-network
    restart: unless-stopped

  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: mahjong-mysql
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=root_password
      - MYSQL_DATABASE=mahjong_prod
      - MYSQL_USER=mahjong_user
      - MYSQL_PASSWORD=mahjong_password
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql/init:/docker-entrypoint-initdb.d
      - ./mysql/conf.d:/etc/mysql/conf.d
    networks:
      - mahjong-network
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: mahjong-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./redis/redis.conf:/etc/redis/redis.conf
    command: redis-server /etc/redis/redis.conf
    networks:
      - mahjong-network
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:

networks:
  mahjong-network:
    driver: bridge
```

### 10.3 监控和日志规范

#### 10.3.1 应用监控配置
```java
// 监控配置
@Configuration
public class MonitoringConfig {

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags(
                "application", "mahjong-game",
                "version", "1.0.0"
        );
    }

    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }

    @Bean
    public CountedAspect countedAspect(MeterRegistry registry) {
        return new CountedAspect(registry);
    }
}

// 服务层监控
@Service
public class GameServiceImpl implements GameService {

    @Timed(value = "game.start", description = "游戏开始耗时")
    @Counted(value = "game.start.count", description = "游戏开始次数")
    public GameResult startGame(String roomId) {
        long startTime = System.currentTimeMillis();

        try {
            // 游戏开始逻辑
            GameResult result = doStartGame(roomId);

            // 记录成功指标
            Metrics.counter("game.start.success", "room_id", roomId).increment();

            return result;
        } catch (Exception e) {
            // 记录失败指标
            Metrics.counter("game.start.failure", "room_id", roomId, "error", e.getClass().getSimpleName()).increment();
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            Metrics.timer("game.start.duration").record(duration, TimeUnit.MILLISECONDS);
        }
    }
}
```

#### 10.3.2 日志配置
```yaml
# logback-spring.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/mahjong.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/mahjong.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
            <totalSizeCap>3GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 错误日志单独记录 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- Spring配置 -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="FILE" />
        </root>
    </springProfile>

    <springProfile name="test">
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="FILE" />
        </root>
    </springProfile>

    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>

        <!-- 业务日志单独配置 -->
        <logger name="com.mahjong" level="DEBUG" additivity="false">
            <appender-ref ref="FILE" />
        </logger>
    </springProfile>
</configuration>
```

## 11. 项目维护规范

### 11.1 代码重构规范

#### 11.1.1 重构时机
```
触发重构的条件：
1. 代码重复率高（超过3次重复）
2. 方法过长（超过50行）
3. 类过大（超过500行）
4. 圈复杂度过高（超过10）
5. 性能出现瓶颈
6. 添加新功能困难
7. 代码难以理解和维护

重构原则：
1. 小步快跑，频繁提交
2. 保持测试用例通过
3. 先添加测试，再重构代码
4. 一次只重构一个方面
5. 保持API接口稳定
```

#### 11.1.2 重构示例
```java
// 重构前：复杂的业务逻辑
public class GameService {
    public GameResult startGame(String roomId) {
        // 获取房间
        Room room = roomRepository.findById(roomId)
                .orElseThrow(() -> new RoomNotFoundException(roomId));

        // 验证房间状态
        if (room.getStatus() != RoomStatus.WAITING) {
            throw new GameAlreadyStartedException(roomId);
        }

        // 验证玩家数量
        if (room.getPlayers().size() < 2) {
            throw new NotEnoughPlayersException(room.getPlayers().size(), 2);
        }

        // 验证所有玩家都准备好了
        boolean allReady = room.getPlayers().stream()
                .allMatch(player -> player.getStatus() == PlayerStatus.READY);
        if (!allReady) {
            throw new NotAllPlayersReadyException();
        }

        // 创建游戏
        Game game = new Game();
        game.setRoomId(room.getId());
        game.setStatus(GameStatus.PLAYING);
        game.setStartTime(LocalDateTime.now());

        // 初始化牌堆
        List<Tile> tiles = createTileDeck();
        Collections.shuffle(tiles);
        game.setWallTiles(tiles);

        // 分发手牌
        Map<String, List<Tile>> hands = dealTiles(tiles, room.getPlayers());
        game.setPlayerHands(hands);

        // 设置庄家
        Player dealer = selectDealer(room.getPlayers());
        game.setDealerId(dealer.getId());

        // 保存游戏
        game = gameRepository.save(game);

        // 更新房间状态
        room.setStatus(RoomStatus.PLAYING);
        roomRepository.save(room);

        // 发送WebSocket通知
        webSocketService.sendGameStart(roomId, game);

        return GameResult.fromEntity(game);
    }
}

// 重构后：职责分离
public class GameServiceImpl implements GameService {

    private final GameValidator gameValidator;
    private final GameInitializer gameInitializer;
    private final GameNotifier gameNotifier;

    @Override
    @Transactional
    public GameResult startGame(String roomId) {
        // 验证游戏可以开始
        GameStartValidation validation = gameValidator.validateGameStart(roomId);

        // 初始化游戏
        Game game = gameInitializer.initializeGame(validation);

        // 发送通知
        gameNotifier.notifyGameStart(roomId, game);

        return GameResult.fromEntity(game);
    }
}

// 验证器
@Component
public class GameValidator {

    public GameStartValidation validateGameStart(String roomId) {
        Room room = getAndValidateRoom(roomId);
        validateRoomStatus(room);
        validatePlayerCount(room);
        validatePlayerReadiness(room);

        return new GameStartValidation(room);
    }

    private void validateRoomStatus(Room room) {
        if (room.getStatus() != RoomStatus.WAITING) {
            throw new GameAlreadyStartedException(room.getId());
        }
    }

    // 其他验证方法...
}

// 初始化器
@Component
public class GameInitializer {

    public Game initializeGame(GameStartValidation validation) {
        Room room = validation.getRoom();

        Game game = Game.builder()
                .roomId(room.getId())
                .status(GameStatus.PLAYING)
                .startTime(LocalDateTime.now())
                .build();

        // 初始化牌堆
        game.setWallTiles(tileDeckService.createAndShuffleDeck());

        // 分发手牌
        game.setPlayerHands(tileDistributionService.dealTiles(game, room.getPlayers()));

        // 设置庄家
        game.setDealerId(dealerSelector.selectDealer(room.getPlayers()));

        return gameRepository.save(game);
    }
}
```

### 11.2 技术债务管理

#### 11.2.1 技术债务记录
```markdown
## 技术债务记录

### 1. 前端性能问题
- **描述**: 游戏页面在低端设备上渲染缓慢
- **影响**: 用户体验差，可能导致用户流失
- **解决方案**: 实现虚拟滚动，优化组件渲染
- **优先级**: 高
- **预计工作量**: 3人天
- **负责人**: 前端团队
- **截止日期**: 2024-02-01

### 2. 数据库查询优化
- **描述**: 某些查询存在N+1问题
- **影响**: 响应时间长，服务器压力大
- **解决方案**: 使用JOIN FETCH或批量查询
- **优先级**: 中
- **预计工作量**: 2人天
- **负责人**: 后端团队
- **截止日期**: 2024-01-15

### 3. 代码重复
- **描述**: 多个Controller存在相似的异常处理逻辑
- **影响**: 代码维护困难
- **解决方案**: 提取公共的异常处理类
- **优先级**: 低
- **预计工作量**: 1人天
- **负责人**: 后端团队
- **截止日期**: 2024-01-31
```

#### 11.2.2 技术债务评估标准
```
优先级评估维度：
1. 影响范围（代码覆盖率、用户覆盖率）
2. 严重程度（系统稳定性、用户体验）
3. 修复成本（开发时间、测试时间）
4. 风险评估（修复可能引入的新问题）

优先级矩阵：
- 高优先级：影响核心功能、用户体验严重受影响
- 中优先级：影响次要功能、有一定性能影响
- 低优先级：代码质量问题、不影响用户使用

技术债务处理策略：
- 每个迭代处理1-2个高优先级债务
- 每个季度处理所有中优先级债务
- 每年处理所有低优先级债务
```

## 12. 总结

本开发规范文档涵盖了河南麻将项目从前端到后端的完整开发流程，包括：

1. **代码风格规范** - 确保代码一致性和可读性
2. **前端开发规范** - Vue 3 + JavaScript最佳实践
3. **后端开发规范** - Spring Boot企业级开发标准
4. **数据库开发规范** - 数据设计和SQL编写规范
5. **测试开发规范** - 完整的测试策略
6. **性能优化规范** - 前后端性能优化指南
7. **安全开发规范** - 安全编码实践
8. **Git工作流规范** - 版本控制和协作规范
9. **部署运维规范** - 容器化和监控规范
10. **项目维护规范** - 代码重构和技术债务管理

### 遵循这些规范的好处：

1. **提高代码质量** - 统一的编码标准和最佳实践
2. **增强团队协作** - 清晰的职责划分和沟通规范
3. **降低维护成本** - 良好的代码结构和文档
4. **提升开发效率** - 标准化的开发流程和工具
5. **保证系统稳定** - 完善的测试和安全措施
6. **便于技术传承** - 详细的文档和规范说明

所有开发人员都应该深入理解并严格遵循这些规范，在开发过程中不断学习和改进，共同维护项目的技术水平和代码质量。